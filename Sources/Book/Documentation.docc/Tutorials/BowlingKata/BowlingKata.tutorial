@Tutorial(time: 30) {
    @Intro(title: "TDD-ката: боулинг") {
        «Разработка через тестирование» предлагает изменить привычку и сначала писать тест, а затем уже продакшен код для теста. 
        
        Чтобы процесс шел проще придумали простые задания, цель которых — научиться писать много тестов, буквально на каждое действие в коде. Такие задания назвали TDD-катами.  
        
        1. <doc:2-1-TDD-Kata>
        @Image(source: <#file#>, alt: "<#accessible description#>")
    }
    
    @Section(title: "Пишем первые тесты") {
        @ContentAndMedia {
            На катах легко отработать принцип «условия задачи меняются в процессе», поэтому не будем заранее читать все правила, пусть код меняется в процессе от новых требований. Тесты должны создать сеть проверок, которые сделают наш рефакторинг безопасным. 
            
            @Image(source: SafetyNet.png, alt: "Файл со свифт-кодом падает в сеть, на узлах сети зеленые галочки от пройденных тестов")
        }
        
        @Steps {
            @Step {
                Нам надо начать с простейшего условия. Чаще всего подходят разные «нулевые» состояния. Так и запишем: в начале игры должно быть 0 очков. 
                
                Код начну писать в этом же файле. 
                
                > Tip: Основной объект тестирования я всегда называю `sut` – `system under test`, т.е. объект тестирования. Когда в тесте будут и другие объекты это упростит понимание «а кого мы тут вообще тестируем»
                
                @Code(name: "Tests.swift", file: TDD-0.swift)
            }
            
            @Step {
                Теперь можно подумать какое минимальное действие мы можем протестировать. Хорошо подходит учет броска со сбитием одной кегли.  
                Я только ввел `func roll`, а Xcode сначала предложил и название и тело теста. 
                
                @Code(name: "Tests.swift", file: TDD-1.swift) {
                    @Image(source: TestSuggestion.png, alt: "Предложенный код изображается прозрачным текстом")
                }
            }
            
            @Step {
                Немного причешем наш код: хочется отделить три шага, который есть почти в каждом тесте: **Arrange** – подготовка тестируемого объекта, **Act** — вызов нужного действия, **Assert** — проверка нового состояния системы. 
                
                Редко получается, чтобы в каждом шаге была только одна строчка, но отделать пустой строкой можно даже в сложных тестах. 
                
                @Code(name: "Tests.swift", file: TDD-1-2.swift)
            }
            
            @Step {
                А какой минимальный код нужно дописать, чтобы этот тест выполнился, но мы не протестировали слишком много? Забавно, но достаточно целиком прировнять переданное значение. Ну и заменить константу на `var`. 
                
                > Tip: стоит запускать сразу все тесты нажимая `CMD+U`, так вы не пропустите упавший тест, если что-то сломаете новым изменением. 
                
                @Code(name: "Tests.swift", file: TDD-2.swift)
            }
            
            @Step {
                Мы знаем, что поведение нашего кода неправильное, но наша задача для тренировки новых подходов научиться «прощупывать» поведение кода через тесты. Допишем тест, который заставит изменить код. Сделаем два броска подряд. 
                
                @Code(name: "Tests.swift", file: TDD-3.swift)
            }
            
            @Step {
                После нескольких тестов можно подумать что можно улучшить в их коде. Пока тесты очень простые, но во всех повторяется код по проверке счета. Мы можем вынести проверку в отдельную функцию.
                
                У такой функции есть проблема: если тест покажет ошибку, то место ошибки окажется внутри функции, прямо на `#expect`! Нам надо, чтобы подсвечивались именно тесты. 
                
                > Tip: называйте все проверки с одинакового ключевого слова. В `XCTest` чаще использовали `assert`, в `Swift Testing` все перешли на `expect`. `Nimble` тоже использует `expect`. 
                
                @Code(name: "Tests.swift", file: TDD-4.swift) {
                    @Image(source: WrongSourceLocation.png, alt: "Ошибка показывается внутри функции, а не в тесте") 
                }
            }
            
            @Step {
                Чтобы захватить параметры строки, в которой надо показывать ошибку в макросе expect есть дефолтный параметр `sourceLocation` — мы можем тоже собирать его и передавать в `#expect`, тогда ошибка будет подсвечиваться правильно. 
                
                @Code(name: "Tests.swift", file: TDD-5.swift) {
                    @Image(source: CorrectSourceLocation.png, alt: "При правильном указании `sourceLocation` ошибки показываются в тесте") 
                }
            }
        }
    }
}
