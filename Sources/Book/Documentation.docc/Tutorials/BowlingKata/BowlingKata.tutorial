@Tutorial(time: 30) {
    @Intro(title: "TDD-ката: боулинг") {
        «Разработка через тестирование» предлагает изменить привычку и сначала писать тест, а затем уже продакшен код для теста. 
        
        Чтобы процесс шел проще придумали простые задания, цель которых — научиться писать много тестов, буквально на каждое действие в коде. Такие задания назвали TDD-катами.  
        
        1. <doc:2-1-TDD-Kata>
        
        @Image(source: TDD-cycle.PNG, alt: "TDD-цикл состоит из трех повторяющихся шагов: красных тестов, зеленых тестов и рефакторинга")
    }
    
    @Section(title: "Пишем первые тесты") {
        @ContentAndMedia {
            На катах легко отработать принцип «условия задачи меняются в процессе», поэтому не будем заранее читать все правила, пусть код меняется в процессе от новых требований. Тесты должны создать сеть проверок, которые сделают наш рефакторинг безопасным. 
            
            @Image(source: SafetyNet.png, alt: "Файл со свифт-кодом падает в сеть, на узлах сети зеленые галочки от пройденных тестов")
        }
        
        @Steps {
            @Step {
                В качестве задачки возьмем [расчет очков для боулинга](https://kata-log.rocks/bowling-game-kata).

                Нам надо начать с простейшего условия. Чаще всего подходят разные «нулевые» состояния. Так и запишем: в начале игры должно быть 0 очков. Код начну писать в этом же файле. 
                
                > Tip: Основной объект тестирования я всегда называю `sut` – `system under test`, т.е. объект тестирования. Когда в тесте будут и другие объекты это упростит понимание «а кого мы тут вообще тестируем»
                
                @Code(name: "Tests.swift", file: TDD-0.swift)
            }
            
            @Step {
                Теперь можно подумать какое минимальное действие мы можем протестировать. Хорошо подходит учет броска со сбитием одной кегли.  
                Я только ввел `func roll`, а Xcode сначала предложил и название и тело теста. 
                
                @Code(name: "Tests.swift", file: TDD-1.swift) {
                    @Image(source: TestSuggestion.png, alt: "Предложенный код изображается прозрачным текстом")
                }
            }
            
            @Step {
                Немного причешем наш код: хочется отделить три шага, который есть почти в каждом тесте: **Arrange** – подготовка тестируемого объекта, **Act** — вызов нужного действия, **Assert** — проверка нового состояния системы. 
                
                Редко получается, чтобы в каждом шаге была только одна строчка, но отделать пустой строкой можно даже в сложных тестах. 
                
                @Code(name: "Tests.swift", file: TDD-1-2.swift)
            }
            
            @Step {
                А какой минимальный код нужно дописать, чтобы этот тест выполнился, но мы не протестировали слишком много? Забавно, но достаточно целиком прировнять переданное значение. Ну и заменить константу на `var`. 
                
                > Tip: стоит запускать сразу все тесты нажимая `CMD+U`, так вы не пропустите упавший тест, если что-то сломаете новым изменением. 
                
                @Code(name: "Tests.swift", file: TDD-2.swift)
            }
            
            @Step {
                Мы знаем, что поведение нашего кода неправильное, но наша задача для тренировки новых подходов научиться «прощупывать» поведение кода через тесты. Допишем тест, который заставит изменить код. Сделаем два броска подряд. 
                
                @Code(name: "Tests.swift", file: TDD-3.swift)
            }
            
            @Step {
                После нескольких тестов можно подумать что можно улучшить в их коде. Пока тесты очень простые, но во всех повторяется код по проверке счета. Мы можем вынести проверку в отдельную функцию.
                
                У такой функции есть проблема: если тест покажет ошибку, то место ошибки окажется внутри функции, прямо на `#expect`! Нам надо, чтобы подсвечивались именно тесты. 
                
                > Tip: называйте все проверки с одинакового ключевого слова. В `XCTest` чаще использовали `assert`, в `Swift Testing` все перешли на `expect`. `Nimble` тоже использует `expect`. 
                
                @Code(name: "Tests.swift", file: TDD-4.swift) {
                    @Image(source: WrongSourceLocation.png, alt: "Ошибка показывается внутри функции, а не в тесте") 
                }
            }
            
            @Step {
                Чтобы захватить параметры строки, в которой надо показывать ошибку в макросе expect есть дефолтный параметр `sourceLocation` — мы можем тоже собирать его и передавать в `#expect`, тогда ошибка будет подсвечиваться правильно. 
                
                @Code(name: "Tests.swift", file: TDD-5.swift) {
                    @Image(source: CorrectSourceLocation.png, alt: "При правильном указании `sourceLocation` ошибки показываются в тесте") 
                }
            }
        }
    }
    
    @Section(title: "Фреймы и спейры") {
        @ContentAndMedia {
            Усложним правила игры в боулинг: протестируем как игра делится на раунды (их называют фреймами, потому что рамка очищает дорожку от кеглей) и что будет если сбить все 10 кегль. 
            
            @Image(source: CraigBowling.png, alt: "Крейг Фидериге бросает шар для боулинга и сбивает кегли")
        }
        
        @Steps {
            @Step {
                Для начала введем ограничение: за один раунд можно бросить шар только два раза, при этом максимальное количество кеглей не может быть больше 10. 
                
                @Code(name: "Tests.swift", file: TDD-6.swift)
            }
            
            @Step {
                Со стороны кода будет сильно больше изменений: теперь нам нужно учитывать порядок бросков, а значит лучше их складывать в массив и уже по массиву. 
                
                Если мы пойдем рефакторить, то новый тест еще долго не позеленеет. Поэтому его можно отключить, отрефакторить код, убедиться, что все тесты зеленые, а потом добавить новый тест. 
                
                @Code(name: "Refactoring.swift", file: TDD-7.swift)
            }
            
            @Step {
                И вот тут у нас проблема с тем, что изменений ожидается много: надо отделить валидацию входных значений от расчет очков, при этом проверять четность броска и только для второго сравнивать сумму. 
                
                Давайте так и запишем! Тест позволяет нам не придумывать сложных абстракций и начать с простого кода, озеленить тест и уже потом думать как двигаться дальше. 
                
                @Code(name: "Refactoring.swift", file: TDD-7-2.swift)
            }
            
            @Step {
                На следующем шаге я могу усложнить этот же код и добавить проверку на четность бросков для всех раундов.
                
                При этом в коде четность текущего броска определяется по нечетности уже совершенных бросков... вот в такие моменты и нужны тесты: сначала код может выходить очень непонятный, но тесты подстрахуют нас и в дальнейшем рефакторинге. 
                
                @Comment {
                    // TODO: показать рефакторинг как важную часть процесса
                }
                
                > Note: мы пропустили валидацию минимального и максимального размера броска, но там ничего особенного нет. 
                
                @Code(name: "Refactoring.swift", file: TDD-8.swift)
            }
            
            @Step {
                Усложним задачку. Если за один раунд игрок сбивает все 10 кегль, то следующий бросок удваивается. 
                
                Чтобы повторить условие в тесте достаточно просто три раза вызвать бросок с разными цифрами, но читать такой тест сложно. 
                
                @Code(name: "Tests.swift", file: TDD-9.swift)
            }
            
            @Step {
                Сначала приберем структуру теста: первые два броска становятся первой arrange-честью теста, а в основном теле остается один бросок, который должен удвоиться.
                
                Во вторых мы можем более явно показать расчет очков прямо внутри `expectScore`
                
                @Code(name: "Tests.swift", file: TDD-10.swift)
            }
            
            @Step {
                Еще мы можем явно ввести функцию `spare`: так мы и себе от ошибок убережем и тест станет более читаемый. 
                
                @Code(name: "Tests.swift", file: TDD-11.swift)
            }
            
            @Step {
                Снова вернемся к рефакторингу: в каждом тесте есть создание объекта, можно убрать это дублирование. Для этого вынесем создание объекта игры на уровень `@Suite`. 
                
                > Warning: `sut` хоть и описан один раз в `@Suite`, но для каждого теста будет создаваться уникальный объект, чтобы тесты не зависели друг от друга. Такое поведение по-разному записывается в разных фреймворках, уточняйте как переиспользуется объекты и их зависимости в документации. 
                
                @Comment {
                    // TODO: ссылку на статью про жизненный цикл теста и разницу между XCTest и Swift Testing
                }
                
                @Code(name: "Tests.swift", file: TDD-12.swift)
            }
            
            @Step {
                Теперь структура arrange-act-assert снова читается в нашем тесте. 
                
                @Code(name: "TestsStructure.swift", file: TDD-13.swift)
            }
            
            @Step {
                Если вы чувствуете, что вам мешается обращение к `sut` в каждой строчке, то это тоже можно упростить. Делать так всегда не рекомендую, но чем сложнее тестируемая система тем больше вокруг нее появляется DSL. Главное, чтобы тесты было удобно читать и поддерживать!
                
                @Code(name: "NoSut.swift", file: TDD-14.swift)
            }
        }
    }
    
    @Section(title: "Страйки и максимум") {
        @ContentAndMedia {
            Давайте еще немного обсудим DSL на примере самых длинных тестов
            
            @Comment {
                // TODO: заменить крейга
            }
            
            @Image(source: CraigBowling.png, alt: "Крейг Фидериге бросает шар для боулинга и сбивает кегли")
        }
        
        @Steps {
            @Step {
                Когда мы начнем писать расчет страйков, то для этого стоит завести отдельную функцию. 
                
                Каждый раз вызывать `roll(10)` было бы несложно, но в этом и проявляется особенность DSL: мы привносим больше бизнес-языка в наши тесты, при этом продакшен-коду это даже не понадобится. Зато тесты потом поддерживать легко. 
                
                @Code(name: "Tests.swift", file: TDD-15.swift)
            }
            
            @Step {
               Закончим максимальным расчетом очков. В игре 10 раундов, в каждом из них можно бросить страйк. Так устроены правила, что для полного учета всех страйков вам дадут два дополнительных броска и вы сможете выбить 300 очков. 
               
               Можно записать это «в лоб», но тест становится слишком «техногенным». 
               
                @Code(name: "Tests.swift", file: TDD-16.swift)
            }
            
            @Step {
                Дополнительный DSL может упростить и этот тест. 
                
                
                @Code(name: "Tests.swift", file: TDD-17.swift)
            }
            
            @Step {
                В итоге на несложной задаче по расчету очков мы можем написать 15-20 тестов, потренировараться с разными аспектами тестов, почувствовать что в тестах нравятся, а что нет и выработать привычку писать тесты если не раньше кода, то прям вместе с ним.
                
                Полный пример тестов [в репозитории](https://github.com/akaDuality/BowlingKata/tree/master). В разных ветках тесты на разных фреймворках
                
                @Comment {
                    // TODO: переписать на Swift Testing и добавить скриншот переключения веток
                }
            }
        }
    }
}

@Comment {
    // TODO: рассказать, что начинать тест можно с ассерта
    // TODO: про нейминг given when then
}
